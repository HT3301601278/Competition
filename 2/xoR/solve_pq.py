import math

# 已知值
N = 81616793159567136422389758585591940662857576283302867011800445277592420866836093507411736040996742950676922327919824777893118631113867500244368612517429678572193116622664051815861481500355863477109385340706136160893878015686817479333596425572252594901263332045777914789662665019123717287533930696370434650226
x = 81616793159567136422389758585591940662857576283302867011800445277592420866836093507411736040996742950676922327919824777893118631113867500244368612517429678572193116622664051815861481500355863477109385340706136160893878015686817479333596425572252594901263332045777914789662665019123717287533930696370434650226

def recover_pq(N, x):
    """
    尝试通过已知的 N 和 x 恢复 p 和 q。
    由于 p 和 q 的值非常大，直接暴力搜索不可行。
    本方法采用从 sqrt(N) 开始的迭代搜索，步长可根据实际情况调整。
    """
    sqrt_N = math.isqrt(N)
    print(f"开始搜索 p，初始值近似 sqrt(N) = {sqrt_N}")

    # 设置搜索范围，假设 p 和 q 的差异不超过一定范围
    # 这里示例设置为 ±10^6，根据实际情况可能需要调整
    delta = 10**10
    lower = sqrt_N - delta
    upper = sqrt_N + delta

    for p in range(lower, upper):
        q = p ^ x
        if p * q == N:
            return p, q
        if p % 100000 == 0:
            print(f"当前 p = {p}, 尚未找到匹配的 q")
    return None, None

p, q = recover_pq(N, x)

if p and q:
    print(f"找到 p = {p}")
    print(f"找到 q = {q}")
else:
    print("未能找到符合条件的 p 和 q，请尝试扩大搜索范围或采用其他方法。")

